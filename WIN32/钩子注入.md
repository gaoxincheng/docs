*NOTE:* 最近在做游戏直播窗口抓取相关调研，期间也看了OBS相关源码，现简单做些学习记录，其中一些个人的看法认知不一定正确。

### 关于HOOK流程

- 要注入的代码逻辑会单独写在一个DLL里，自己的程序和游戏进程最终都会加载该DLL。
- 游戏进程加载自己要注入的DLL是通过`SetWindowsHookExA`方法实现的，其中有一个参数存放要注入DLL的Handler，当游戏进程执行HOOK的消息时，发现没有加载对应的DLL，则会加载相关DLL,`UnhookWindowsHookEx`会卸载相关钩子，目前测试下来`UnhookWindowsHookEx`并不能让游戏进程卸载DLL，暂未找到原因。
- 注入DLL的入口函数`DllMain`中可实现相关游戏绘制函数的HOOK，通常做法是开启线程对游戏绘制函数进行HOOK，`DllMain`可对`DLL_PROCESS_ATTACH`和`DLL_PROCESS_DETACH`进行判断是否加载的是对应的游戏进程.
- 注入的DLL中要对自己的进程作退出监听，防止自己开启的HOOK线程无法正常退出，这可能会被游戏进程认为是外挂。

### 关于游戏采集

```
    对于直播而言，游戏是一个重要分支，对于游戏自身而言，都是为了尽可能争取到高性能的渲染，而基本上采用DirectX、OpenGL、VulKan等与显卡紧密结合的渲染SDK进行游戏画面的渲染，游戏的帧率，也普遍非常之高。高清高速高性能的追求，对于数据采集而言，本就是一个挑战，如果采样前述的窗口捕获的方式，对于DMA带宽占用，本身就会影响当下游戏性能，而且游戏帧率随着场景变化，对于我们设置的采样间隔，会造成极大的浪费。所以，游戏这种捕获，OBS采用了独立功能和产品模块来实现捕获，以获取最佳性能。

    为了能掌控渲染帧数的变化，实时获取图像帧数据，基本方式是：注入 + 绘制函数Hook。
```

### 数据共享方式
- 共享内存
```
    D3D8 不支持纹理共享的方式，目前是HOOK到数据后放到一片共享内存区域，再由其他进程读取该区域数据做编码发送.
```
- 纹理共享
```
    纹理共享 将数据保存在GPU内存中，绕过CPU及其高昂的内存复制操作开销，从而高效地在进程之间发送和接收GPU数据。
    进程通信仍是通过共享内存，只是共享内存存放不是具体的帧数据，而是共享纹理资源的句柄，其他进程可通过该句柄读取相关帧数据.
```


### 参考链接

- [常见的几种DLL注入技术](https://bbs.pediy.com/thread-269910.htm)
- [windows api](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa)
- [windows 屏幕抓取总结](https://blog.csdn.net/tuan8888888/article/details/120761111)